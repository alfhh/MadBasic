package MadBasic;

import MadBasic.Algrebra.*;
import MadBasic.Quadruples.*;
import MadBasic.Quadruples.Gotos.End;
import MadBasic.Quadruples.Gotos.Gosub;
import MadBasic.Quadruples.Gotos.Goto;
import MadBasic.Quadruples.Gotos.GotoFalse;
import MadBasic.Semantic.BasicSemantic;
import MadBasic.Semantic.Class;
import MadBasic.Semantic.Methods.Function;
import MadBasic.Semantic.Methods.Procedure;
import MadBasic.Semantic.Scope;
import MadBasic.Semantic.SemanticCube;
import MadBasic.Semantic.Types.*;
import MadBasic.VMemory.Era;
import MadBasic.VMemory.Instance;
import MadBasic.VMemory.VirtualMemory;
import ParserMadBasic.MadBasicBaseVisitor;
import ParserMadBasic.MadBasicParser;
import org.antlr.v4.runtime.tree.ParseTree;

import java.util.*;

/**
 * Created by MadDevs on 3/10/16, modified daily.
 * This class is the backbone of the project. It extends the BaseVisitor generated by Antlr, and overrides the methods
 * we need to implement the semantics of the language
 */
public class Visitor extends MadBasicBaseVisitor<String> {

    BasicSemantic basicSemantic;
    QuadrupleSemantic quadrupleSemantic;
    VirtualMemory virtualMemory;


    public Visitor() {
        // All instances are cleared
        BasicSemantic.resetInstance();
        QuadrupleSemantic.resetInstance();
        VirtualMemory.resetInstance();

        basicSemantic = BasicSemantic.getInstance();
        quadrupleSemantic = QuadrupleSemantic.getInstance();
        virtualMemory = VirtualMemory.getInstance();
    }

    //------------------------------------------------------------------------------------------BEGIN BASIC SEMANTIC
    /**/
    //------------------------------------------------------------BEGIN TYPES

    /**
     * This function is a child of the rule Type,
     * Recognizes the type Int and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeInt(MadBasicParser.TypeIntContext ctx) {
        String res = visitChildren(ctx);
        basicSemantic.getTypeStack().push(new TypeInt());
        return res;
    }

    /**
     * This function is a child of the rule Type,
     * Recognizes the type Float and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeFloat(MadBasicParser.TypeFloatContext ctx) {
        String res = visitChildren(ctx);
        basicSemantic.getTypeStack().push(new TypeFloat());
        return res;
    }

    /**
     * This function is a child of the rule Type,
     * Recognizes the type String and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeString(MadBasicParser.TypeStringContext ctx) {
        String res = visitChildren(ctx);
        basicSemantic.getTypeStack().push(new TypeString());
        return res;
    }

    /**
     * This function is a child of the rule Type,
     * Recognizes the type Bool and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeBool(MadBasicParser.TypeBoolContext ctx) {
        String res = visitChildren(ctx);
        basicSemantic.getTypeStack().push(new TypeBool());
        return res;
    }

    /**
     * This function is a child of the rule Type,
     * Recognizes the type List and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeList(MadBasicParser.TypeListContext ctx) {
        String res = visitChildren(ctx);
        basicSemantic.getTypeStack().push(new TypeList());
        return res;
    }

    /**
     * This function is a child of the rule Type,
     * Recognizes the type Object and pushes it to the Type stack to be later used.
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitTypeObject(MadBasicParser.TypeObjectContext ctx) {
        String res = visitChildren(ctx);

        basicSemantic.getTypeStack().push(
                new TypeObject(basicSemantic.getClassHashMap().get(ctx.getChild(0).getText())));
        return res;
    }

    /**
     * This function is a child of the rule Array,
     * It creates a TypeArray.Array object and sets its size with the parameters given un the declaration
     *
     * @param ctx Context of the rule
     * @return result
     */
    @Override
    public String visitArrayDeclare(MadBasicParser.ArrayDeclareContext ctx) {
        String res = visitChildren(ctx);
        TypeArray array = new TypeArray();
        array.setArray(new Integer(ctx.getChild(1).getText().concat(ctx.getChild(2).getText())),
                new Integer(ctx.getChild(4).getText().concat(ctx.getChild(5).getText())));
        if (array.getArray().getSize() > 0) {
            if (basicSemantic.getTypeStack().empty()) {
                basicSemantic.getTypeStack().push(array);
            } else {
                if (basicSemantic.getTypeStack().peek() instanceof TypeArray) {
                    array.getArray().setArray(((TypeArray) basicSemantic.getTypeStack().pop()).getArray());
                    basicSemantic.getTypeStack().push(array);
                } else {
                    System.out.println("Error in Array " + basicSemantic.getTypeStack().empty());
                }
            }
        } else {
            System.out.println("Error in Array Size: " + array.getArray().getSize());
        }
        return res;
    }

    //------------------------------------------------------------END TYPES
    /**/
    //------------------------------------------------------------BEGIN VARIABLES

    /**
     * Inserts the var in the vDirectory of the VirtualMemory object, and creates a memory space in de vMemory
     * of the VirtualMemory object;
     *
     * @param var the variable to be inserted
     */
    int insertVDirectory(Variable var) {
        // INT(0), FLOAT(1), STRING(2), BOOL(3), ARRAY(4), OBJECT(5), FALSE(-1);
        int res;
        switch (var.getType().getTypeValue()) {
            case 0:
                virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getIntCount());
                res = virtualMemory.getIntCount();
                virtualMemory.getvMemory().putIfAbsent(res, 0);
                virtualMemory.addIntCount();
                break;
            case 1:
                virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getFloatCount());
                res = virtualMemory.getFloatCount();
                virtualMemory.getvMemory().putIfAbsent(res, new Float(0.0));
                virtualMemory.addFloatCount();
                break;
            case 2:
                virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getStringCount());
                res = virtualMemory.getStringCount();
                virtualMemory.getvMemory().putIfAbsent(res, "\"\"");
                virtualMemory.addStringCount();
                break;
            case 3:
                virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getBoolCount());
                res = virtualMemory.getBoolCount();
                virtualMemory.getvMemory().putIfAbsent(res, false);
                virtualMemory.addBoolCount();
                break;
            case 4:
                switch (((TypeArray) var.getType()).getType().getTypeValue()) {
                    case 0:
                        virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getIntCount());
                        res = virtualMemory.getIntCount();
                        for (int i = res; i < ((TypeArray) var.getType()).getArray().getSize() + res; i++) {
                            virtualMemory.getvMemory().putIfAbsent(i, 0);
                        }
                        virtualMemory.setIntCount(res + ((TypeArray) var.getType()).getArray().getSize());
                        break;
                    case 1:
                        virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getFloatCount());
                        res = virtualMemory.getFloatCount();
                        for (int i = res; i < ((TypeArray) var.getType()).getArray().getSize() + res; i++) {
                            virtualMemory.getvMemory().putIfAbsent(i, new Float(0.0));
                        }
                        virtualMemory.setFloatCount(res + ((TypeArray) var.getType()).getArray().getSize());
                        break;
                    case 2:
                        virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getStringCount());
                        res = virtualMemory.getStringCount();
                        for (int i = res; i < ((TypeArray) var.getType()).getArray().getSize() + res; i++) {
                            virtualMemory.getvMemory().putIfAbsent(i, "\"\"");
                        }
                        virtualMemory.setStringCount(res + ((TypeArray) var.getType()).getArray().getSize());
                        break;
                    case 3:
                        virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getBoolCount());
                        res = virtualMemory.getBoolCount();
                        for (int i = res; i < ((TypeArray) var.getType()).getArray().getSize() + res; i++) {
                            virtualMemory.getvMemory().putIfAbsent(i, false);
                        }
                        virtualMemory.setBoolCount(res + ((TypeArray) var.getType()).getArray().getSize());
                        break;
                    case 5:
                        //Gets the class of the Array
                        Class clas = ((TypeObject) (((TypeArray) var.getType()).getType())).getClasse();
                        virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getInstanceCount());
                        res = virtualMemory.getInstanceCount();
                        for (int i = 0; i < ((TypeArray) var.getType()).getArray().getSize(); i++) {
                            Instance instance = new Instance();
                            Class c = clas;
                            //Iterate through the parent classes to allocate attributes of the object
                            while (c != null) {
                                for (Variable variable : c.getScope().getVariableHashMap().values()) {
                                    instance.getvDirectory().putIfAbsent(variable.getID(), insertVDirectory(
                                            new Variable((res + i) + "." + variable.getID(),
                                                    variable.getType(), variable.getScope())));
                                }
                                //Creates the Era for each method of the class
                                for (Procedure proc : c.getScope().getProcedureHashMap().values()) {
                                    Era era = new Era();
                                    for (Variable v : proc.getScope().getVariableHashMap().values()) {
                                        era.getvDirectory().put(v.getID(), null);
                                    }
                                    Set<String> k = proc.getEra().keySet();
                                    Object[] keys = k.toArray();
                                    for (Object key : keys) {
                                        if (instance.getvDirectory().containsKey(key)) {
                                            era.getvDirectory().put((String) key, instance.getvDirectory().get(key));
                                        } else {
                                            era.getvDirectory().put((String) key, null);
                                        }
                                    }
                                    era.setStart(proc.getQuadrupleStart());
                                    era.setParams(proc.getParams());
                                    instance.getEraHashMap().put(proc.getID(), era);
                                }
                                c = c.getParent();
                            }
                            virtualMemory.getvMemory().putIfAbsent(virtualMemory.getInstanceCount(), instance);
                            virtualMemory.addInstanceCount();
                        }
                        break;
                    default:
                        res = -1;
                        break;
                }
                break;
            case 5:
                Class clas = ((TypeObject) var.getType()).getClasse();
                Instance instance = new Instance();
                //Iterate through the parent classes to allocate attributes of the object
                while (clas != null) {
                    for (Variable variable : clas.getScope().getVariableHashMap().values()) {
                        instance.getvDirectory().putIfAbsent(variable.getID(), insertVDirectory(
                                new Variable(var.getID() + "." + variable.getID(),
                                        variable.getType(), variable.getScope())));
                    }
                    for (Procedure proc : clas.getScope().getProcedureHashMap().values()) {
                        Era era = new Era();
                        for (Variable v : proc.getScope().getVariableHashMap().values()) {
                            era.getvDirectory().put(v.getID(), null);
                        }
                        Set<String> k = proc.getEra().keySet();
                        Object[] keys = k.toArray();
                        for (Object key : keys) {
                            if (instance.getvDirectory().containsKey(key)) {
                                era.getvDirectory().put((String) key, instance.getvDirectory().get(key));
                            } else {
                                era.getvDirectory().put((String) key, null);
                            }
                        }
                        era.setStart(proc.getQuadrupleStart());
                        era.setParams(proc.getParams());
                        instance.getEraHashMap().put(proc.getID(), era);
                    }
                    clas = clas.getParent();
                }
                virtualMemory.getvDirectory().putIfAbsent(var.getID(), virtualMemory.getInstanceCount());
                res = virtualMemory.getInstanceCount();
                virtualMemory.getvMemory().putIfAbsent(res, instance);
                virtualMemory.addInstanceCount();
                break;
            default:
                res = -1;
                break;
        }

        return res;
    }


    /**
     * Inserts the var in the vDirectory of the VirtualMemory object, and creates a memory space in de vMemory
     * of the VirtualMemory object;
     * todo Arrays and Objects on tempvDirectory
     *
     * @param temp
     */
    int insertTempVDirectory(Temporal temp) {
        // INT(0), FLOAT(1), STRING(2), BOOL(3), ARRAY(4), OBJECT(5), FALSE(-1);
        int res = 0;
        switch (temp.getType().getTypeValue()) {
            case 0:
                virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(temp), virtualMemory.getTempIntCount());
                res = virtualMemory.getTempIntCount();
                virtualMemory.getvMemory().putIfAbsent(res, 0);
                virtualMemory.addTempIntCount();
                break;
            case 1:
                virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(temp), virtualMemory.getTempFloatCount());
                res = virtualMemory.getTempFloatCount();
                virtualMemory.getvMemory().putIfAbsent(res, new Float(0.0));
                virtualMemory.addTempFloatCount();
                break;
            case 2:
                virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(temp), virtualMemory.getTempStringCount());
                res = virtualMemory.getTempStringCount();
                virtualMemory.getvMemory().putIfAbsent(res, "");
                virtualMemory.addTempStringCount();
                break;
            case 3:
                virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(temp), virtualMemory.getTempBoolCount());
                res = virtualMemory.getTempBoolCount();
                virtualMemory.getvMemory().putIfAbsent(res, false);
                virtualMemory.addTempBoolCount();
                break;
            default:
                res = -1;
                break;
        }
        return res;
    }

    /**
     * Sets the Reference boolean in the BasicSemantic instance to true to be used in later rules
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitReference(MadBasicParser.ReferenceContext ctx) {
        String result = visitChildren(ctx);
        basicSemantic.setFoundAReference(true);
        return result;
    }

    /**
     * This function adds Variables in a row to the Variable HashMap of the current scope if it is not in
     * a class declaration or inside a method
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitE(MadBasicParser.EContext ctx) {
        String result = "";

        ParseTree c = ctx.getChild(0);
        String childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);

        Type type = basicSemantic.getTypeStack().pop();
        while (!basicSemantic.getTypeStack().empty()) {
            if (type instanceof TypeList) {
                ((TypeList) type).setType(basicSemantic.getTypeStack().pop());
            } else if (basicSemantic.getTypeStack().peek() instanceof TypeArray) {
                ((TypeArray) basicSemantic.getTypeStack().peek()).setType(type);
                type = basicSemantic.getTypeStack().pop();
            }
        }

        int n = ctx.getChildCount();
        for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            c = ctx.getChild(i);
            childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        LinkedList<String> ids = new LinkedList<>();
        ids.add(ctx.getChild(1).getText());
        ids.addAll(Arrays.asList(ctx.getChild(2).getText().trim().split(",")));
        for (String id : ids) {
            if (id.trim().length() > 0) {
                Variable var = new Variable(id, type, basicSemantic.getScopeStack().peek());
                basicSemantic.getVariables().add(var);
                basicSemantic.getScopeStack().peek().addVariable(var);
                if (!basicSemantic.getClassHashMap().containsKey(var.getScope().getName())
                        && !basicSemantic.isInMethod()) {
                    insertVDirectory(var);
                }
            }
        }
        return result;
    }

    //------------------------------------------------------------END VARIABLES
    /**/
    //------------------------------------------------------------BEGIN CLASS AND MAIN

    /**
     * This function sets the hasParent boolean of the BasicSemantic instance to true to be used in later functions
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitDParent(MadBasicParser.DParentContext ctx) {
        basicSemantic.setHasParent(true);
        basicSemantic.setParent(ctx.getChild(1).getText());
        return super.visitDParent(ctx);
    }

    /**
     * This functions analyzes a class and adds it to the Class HashMap of the BasicSemantic instance
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitClasse(MadBasicParser.ClasseContext ctx) {
        String result = "";

        int parentRule = 3;
        for (int i = 0; i < parentRule && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        String name = ctx.getChild(1).getText();

        Scope scp = new Scope(name, basicSemantic.getScopeStack().peek());
        basicSemantic.getScopes().add(scp);
        basicSemantic.getScopeStack().push(scp);

        if (!basicSemantic.getClassHashMap().containsKey(name)) {
            Class classe = new Class(name, scp);
            if (basicSemantic.isHasParent()) {
                if (basicSemantic.getClassHashMap().containsKey(basicSemantic.getParent())) {
                    classe.setParent(basicSemantic.getClassHashMap().get(basicSemantic.getParent()));
                } else {
                    System.out.println("Error in " + name);
                }
                basicSemantic.setHasParent(false);
            }
            basicSemantic.getClassHashMap().put(name, classe);
        } else {
            System.out.println("Error in " + name);
        }


        int n = ctx.getChildCount();
        for (int i = parentRule; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        basicSemantic.getScopeStack().pop();
        return result;
    }

    /**
     * This function creates the first Goto to go to the main, forms the Era's for the global functions and
     * sets the main scope
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitMain(MadBasicParser.MainContext ctx) {
        ((Goto) quadrupleSemantic.getQuadrupleList().get(0)).setJump(quadrupleSemantic.getQuadrupleList().size());

        for (Procedure proc : basicSemantic.getScopeStack().peek().getProcedureHashMap().values()) {
            Era era = new Era();
            for (Variable var : proc.getScope().getVariableHashMap().values()) {
                era.getvDirectory().put(var.getID(), null);
            }
            era.getvDirectory().putAll(proc.getEra());
            era.setStart(proc.getQuadrupleStart());
            era.setParams(proc.getParams());
            virtualMemory.getEraHashMap().put(proc.getID(), era);
        }
        String name = "main";
        Scope scp = new Scope(name, basicSemantic.getScopeStack().peek());
        basicSemantic.getScopes().add(scp);
        basicSemantic.getScopeStack().push(scp);
        String res = visitChildren(ctx);
        basicSemantic.getScopeStack().pop();
        return res;
    }

    //------------------------------------------------------------END CLASS AND MAIN
    /**/
    //------------------------------------------------------------------------------------------END BASIC SEMANTIC
    /**/
    //------------------------------------------------------------------------------------------BEGIN QUADRUPLES
    /**/
    //------------------------------------------------------------BEGIN ASSIGNMENT, READ AND WRITE

    /**
     * @param id
     * @param scope
     * @return
     */
    boolean idSimple(String id, Scope scope) {
        boolean found = false;

        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(id)) {

                Variable var = scope.getVariableHashMap().get(id);
                quadrupleSemantic.getOperandStack().push(var);

                if (var.getScope() != basicSemantic.getScopeStack().peek()
                        && basicSemantic.isInMethod()) {
                    Integer dir = virtualMemory.getvDirectory().get(var.getID());
                    basicSemantic.getEraHash().put(var.getID(), dir);
                }

                quadrupleSemantic.getOperandStack().push(var);

                found = true;
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        return found;
    }

    /**
     * @param id
     * @param scope
     */
    boolean idSimpleArray(String id, Scope scope) {
        boolean found = false;
        id = id.split("\\[")[0];

        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(id)) {

                Variable var = scope.getVariableHashMap().get(id);
                processArray(var);

                if (var.getScope() != basicSemantic.getScopeStack().peek()
                        && basicSemantic.isInMethod()) {
                    Integer dir = virtualMemory.getvDirectory().get(var.getID());
                    basicSemantic.getEraHash().put(var.getID(), dir);
                }

                found = true;
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        return found;
    }

    boolean idSimpleDot(String text, Scope scope) {
        boolean found = false;
        String[] ids = text.split("\\.");
        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(ids[0])) {
                TypeObject obj = (TypeObject) scope.getVariableHashMap().get(ids[0]).getType();

                if ((obj.getClasse().getScope().getVariableHashMap().containsKey(ids[1]))) {
                    Variable var = obj.getClasse().getScope().getVariableHashMap().get(ids[1]);

                    var = new Variable(ids[0] + "." + var.getID(), var.getType(), var.getScope());
                    if ((var).getScope() != basicSemantic.getScopeStack().peek()
                            && basicSemantic.isInMethod()) {
                        Integer dir = virtualMemory.getvDirectory().get((var).getID());
                        basicSemantic.getEraHash().put((var).getID(), dir);
                    }
                    quadrupleSemantic.getOperandStack().push(var);

                    found = true;
                }
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        return found;
    }

    boolean idDotArray(String text, Scope scope) {
        boolean found = false;
        String[] ids = text.split("\\.");
        ids[1] = ids[1].split("\\[")[0];
        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(ids[0])) {
                TypeObject obj = (TypeObject) scope.getVariableHashMap().get(ids[0]).getType();

                if ((obj.getClasse().getScope().getVariableHashMap().containsKey(ids[1]))) {
                    Variable var = obj.getClasse().getScope().getVariableHashMap().get(ids[1]);
                    var = new Variable(ids[0] + "." + var.getID(), var.getType(), var.getScope());
                    processArray(var);
                    if (var.getScope() != basicSemantic.getScopeStack().peek()
                            && basicSemantic.isInMethod()) {
                        Integer dir = virtualMemory.getvDirectory().get(var.getID());
                        basicSemantic.getEraHash().put(var.getID(), dir);
                    }
                    found = true;
                }
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        return found;
    }

    boolean idArrayDot(String text, Scope scope) {
        boolean found = false;
        String[] names = text.split("\\.");
        names[0] = names[0].split("\\[")[0];
        Variable arrObj = null;
        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(names[0])) {
                arrObj = scope.getVariableHashMap().get(names[0]);
                processArray(arrObj);
                found = true;
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        if (found) {
            found = false;
            scope = basicSemantic.getScopeStack().peek();
            while (scope != null && !found) {

                TypeObject obj = (TypeObject) ((TypeArray) arrObj.getType()).getType();

                if (obj.getClasse().getScope().getVariableHashMap().containsKey(names[1])) {
                    Variable var = obj.getClasse().getScope().getVariableHashMap().get(names[1]);
                    var = new Variable(
                            Operand.getIdString(quadrupleSemantic.getOperandStack().pop())
                                    + "." + var.getID(), var.getType(), var.getScope());
                    if ((var).getScope() != basicSemantic.getScopeStack().peek()
                            && basicSemantic.isInMethod()) {
                        Integer dir = virtualMemory.getvDirectory().get((var).getID());
                        basicSemantic.getEraHash().put((var).getID(), dir);
                    }
                    quadrupleSemantic.getOperandStack().push(var);
                    found = true;
                }
                if (!found) {
                    scope = scope.getParent();
                }
            }
        }
        return found;
    }

    boolean idArrayDotArray(String text, Scope scope) {
        boolean found = false;
        String[] names = text.split("\\.");
        names[0] = names[0].split("\\[")[0];
        names[1] = names[1].split("\\[")[0];
        Variable arrObj = null;
        while (scope != null && !found) {
            if (scope.getVariableHashMap().containsKey(names[0])) {
                arrObj = scope.getVariableHashMap().get(names[0]);
                basicSemantic.setArrayandDot(false);
                processArray(arrObj);
                basicSemantic.setArrayandDot(true);
                found = true;
            }
            if (!found) {
                scope = scope.getParent();
            }
        }
        if (found) {
            found = false;
            scope = basicSemantic.getScopeStack().peek();
            while (scope != null && !found) {

                TypeObject obj = (TypeObject) ((TypeArray) arrObj.getType()).getType();

                if (obj.getClasse().getScope().getVariableHashMap().containsKey(names[1])) {
                    Variable var = obj.getClasse().getScope().getVariableHashMap().get(names[1]);
                    var = new Variable(
                            Operand.getIdString(quadrupleSemantic.getOperandStack().pop())
                                    + "." + var.getID(), var.getType(), var.getScope());
                    processArray(var);
                    if (var.getScope() != basicSemantic.getScopeStack().peek()
                            && basicSemantic.isInMethod()) {
                        Integer dir = virtualMemory.getvDirectory().get(var.getID());
                        basicSemantic.getEraHash().put(var.getID(), dir);
                    }
                    found = true;
                }
                if (!found) {
                    scope = scope.getParent();
                }
            }
        }
        return found;
    }

    /**
     * @param ctx
     * @param from
     * @return
     */
    String advanceToContextEndAssignment(MadBasicParser.AssignmentContext ctx, int from) {
        String res = "";
        int n = ctx.getChildCount();
        for (int i = from; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            res = this.aggregateResult(res, childResult);
        }
        return res;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitAssignment(MadBasicParser.AssignmentContext ctx) {
        String res = null;

        ParseTree c = ctx.getChild(0);
        String childResult = c.accept(this);
        res = this.aggregateResult(res, childResult);

        String text = ctx.getChild(0).getText();
        Scope scope = basicSemantic.getScopeStack().peek();
        boolean found = false;
        Operand equal;
        Operand oper;

        if (basicSemantic.isDot()) {
            if (!basicSemantic.isArray()) {
                if (!basicSemantic.isArrayandDot()) {
                    found = idSimpleDot(text, scope);
                } else {
                    found = idDotArray(text, scope);
                    basicSemantic.setArrayandDot(false);
                }
            } else {
                if (!basicSemantic.isArrayandDot()) {
                    found = idArrayDot(text, scope);
                } else {
                    found = idArrayDotArray(text, scope);
                    basicSemantic.setArrayandDot(false);
                }
                basicSemantic.setArray(false);
            }
            basicSemantic.setDot(false);
        } else {
            if (!basicSemantic.isArray()) {
                found = idSimple(text, scope);
            } else {
                found = idSimpleArray(text, scope);
                basicSemantic.setArray(false);
            }
        }
        advanceToContextEndAssignment(ctx, 1);
        oper = quadrupleSemantic.getOperandStack().pop();
        equal = quadrupleSemantic.getOperandStack().pop();
        quadrupleSemantic.getQuadrupleList().add(new Assignment(oper, equal));
//        if (basicSemantic.isDot()) {
//            basicSemantic.setDot(false);
//            String[] names = text.split("\\.");
//            Scope scope = basicSemantic.getScopeStack().peek();
//            Variable arrObj = new Variable(null, null, null);
//            if (basicSemantic.isArray()) {
//                names[0] = names[0].split("\\[")[0];
//                while (scope != null && !found) {
//                    if (scope.getVariableHashMap().containsKey(names[0])) {
//                        arrObj = scope.getVariableHashMap().get(names[0]);
//                        processArray(arrObj);
//                        break;
//                    }
//                    if (!found) {
//                        scope = scope.getParent();
//                    }
//                }
//            }
//            scope = basicSemantic.getScopeStack().peek();
//            while (scope != null && !found) {
//                if (scope.getVariableHashMap().containsKey(names[0])) {
//                    names[1] = names[1].split("\\[")[0];
//                    if (basicSemantic.isArray()) {
//                        basicSemantic.setArray(false);
//                        if (((TypeObject) ((TypeArray) arrObj.getType()).getType()).
//                                getClasse().getScope().getVariableHashMap().containsKey(names[names.length - 1])) {
//                            Variable var =
//                                    ((TypeObject) ((TypeArray) arrObj.getType()).getType()).
//                                            getClasse().getScope().getVariableHashMap().get(names[names.length - 1]);
//                            if (!basicSemantic.isArrayandDot()) {
//                                var = new Variable(
//                                        Operand.getIdString(quadrupleSemantic.getOperandStack().pop())
//                                                + "." + var.getID(), var.getType(), var.getScope());
//                                if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                        && basicSemantic.isInMethod()) {
////                                    System.out.println(var);
//                                    Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                                    basicSemantic.getEraHash().put((var).getID(), dir);
//                                }
//                                quadrupleSemantic.getOperandStack().push(var);
//                                int n = ctx.getChildCount();
//                                for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
//                                    c = ctx.getChild(i);
//                                    childResult = c.accept(this);
//                                    res = this.aggregateResult(res, childResult);
//                                }
//                                Operand oper = quadrupleSemantic.getOperandStack().pop();
//                                quadrupleSemantic.getOperandStack().pop();
//                                // TODO: 4/20/16 semanticCube
//                                quadrupleSemantic.getQuadrupleList().add(new Assignment(oper, var));
//                            } else {
//                                if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                        && basicSemantic.isInMethod()) {
////                                    System.out.println(var);
//                                    Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                                    basicSemantic.getEraHash().put((var).getID(), dir);
//                                }
//                                System.out.println(var);
//                                processArray(var);
//                                basicSemantic.setArrayandDot(false);
//                            }
//                        }
//                        basicSemantic.setArray(false);
//                    } else if (((TypeObject) scope.getVariableHashMap().get(names[0]).getType())
//                            .getClasse().getScope().getVariableHashMap().containsKey(names[1])) {
//                        Variable var =
//                                ((TypeObject) scope.getVariableHashMap().get(names[0]).getType())
//                                        .getClasse().getScope().getVariableHashMap().get(names[1]);
//                        if (!basicSemantic.isArrayandDot()) {
//                            var = new Variable(names[0] + "." + var.getID(), var.getType(), var.getScope());
//                            if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                    && basicSemantic.isInMethod()) {
////                                System.out.println(var);
//                                Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                                basicSemantic.getEraHash().put((var).getID(), dir);
//                            }
//                            quadrupleSemantic.getOperandStack().push(var);
//                            int n = ctx.getChildCount();
//                            for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
//                                c = ctx.getChild(i);
//                                childResult = c.accept(this);
//                                res = this.aggregateResult(res, childResult);
//                            }
//                            Operand oper = quadrupleSemantic.getOperandStack().pop();
//                            quadrupleSemantic.getOperandStack().pop();
//                            // TODO: 4/20/16 semanticCube
//                            quadrupleSemantic.getQuadrupleList().add(new Assignment(oper, var));
//                        } else {
//                            processArray(var);
//                            if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                    && basicSemantic.isInMethod()) {
////                                System.out.println(var);
//                                Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                                basicSemantic.getEraHash().put((var).getID(), dir);
//                            }
//                            basicSemantic.setArrayandDot(false);
//                        }
//                    }
//                    found = true;
//                }
//                if (!found) {
//                    scope = scope.getParent();
//                }
//            }
//        } else {
//            Scope scope = basicSemantic.getScopeStack().peek();
//            while (scope != null && !found) {
//                if (scope.getVariableHashMap().containsKey(text)) {
//                    Variable var = scope.getVariableHashMap().get(text);
//                    if (!basicSemantic.isArray()) {
//                        quadrupleSemantic.getOperandStack().push(var);
//                        if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                && basicSemantic.isInMethod()) {
////                                System.out.println(var);
//                            Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                            basicSemantic.getEraHash().put((var).getID(), dir);
//                        }
//                        int n = ctx.getChildCount();
//                        for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
//                            c = ctx.getChild(i);
//                            childResult = c.accept(this);
//                            res = this.aggregateResult(res, childResult);
//                        }
//                        Operand oper = quadrupleSemantic.getOperandStack().pop();
//                        quadrupleSemantic.getOperandStack().pop();
//                        // TODO: 4/20/16 semanticCube
//                        quadrupleSemantic.getQuadrupleList().add(new Assignment(oper, var));
//                        found = true;
//                    } else {
//                        processArray(var);
//                        if ((var).getScope() != basicSemantic.getScopeStack().peek()
//                                && basicSemantic.isInMethod()) {
////                                System.out.println(var);
//                            Integer dir = virtualMemory.getvDirectory().get((var).getID());
//                            basicSemantic.getEraHash().put((var).getID(), dir);
//                        }
//                        basicSemantic.setArray(false);
//                        int n = ctx.getChildCount();
//                        for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
//                            c = ctx.getChild(i);
//                            childResult = c.accept(this);
//                            res = this.aggregateResult(res, childResult);
//                        }
//                        Operand oper = quadrupleSemantic.getOperandStack().pop();
//                        Operand equal = quadrupleSemantic.getOperandStack().pop();
//                        // TODO: 4/20/16 semanticCube
//                        quadrupleSemantic.getQuadrupleList().add(new Assignment(oper, equal));
//                    }
//                    found = true;
//                }
//                if (!found) {
//                    scope = scope.getParent();
//                }
//            }
//        }
        if (!found) {
            System.out.println("Error, Identifier: " + text + " not found3!");
        }
        return res;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitRead(MadBasicParser.ReadContext ctx) {
        Type type = quadrupleSemantic.getOperandStack().peek().getType();
        Temporal temp = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), type);

        if (basicSemantic.isInMethod()) {
            basicSemantic.getEraHash().put(Operand.getIdString(temp), null);
        } else {
            insertTempVDirectory(temp);
        }

        quadrupleSemantic.getQuadrupleList().add(new Read(temp));
        quadrupleSemantic.getOperandStack().push(temp);
        return super.visitRead(ctx);
    }

    /**
     * This function creates a quadruple (write) with the value of the top of the
     * operandStack
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitWrite(MadBasicParser.WriteContext ctx) {
        String res = visitChildren(ctx);

        // Get the top element of the stack
        Operand output = quadrupleSemantic.getOperandStack().pop();

        // Add to the quadruple
        quadrupleSemantic.getQuadrupleList().add(new Write(output));
        return res;
    }

    /**
     * @param type
     * @return
     */
    boolean isPrimitive(Type type) {
        return !((type instanceof TypeObject)
                || (type instanceof TypeArray)
                || (type instanceof TypeList));
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitQWrite(MadBasicParser.QWriteContext ctx) {
        String res = visitChildren(ctx);
        Operand op1 = quadrupleSemantic.getOperandStack().pop();
        Operand op2 = quadrupleSemantic.getOperandStack().pop();


        //Check the semantic cube
//        Type resT = SemanticCube.getCubeType(op1.getType().getTypeValue(), op2.getType().getTypeValue(), Operator.CARET.getValue());

        //agregar cuadruplo
        if (isPrimitive(op1.getType()) && isPrimitive(op1.getType())) {
            Temporal temp = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), new TypeString());

            if (basicSemantic.isInMethod()) {
                basicSemantic.getEraHash().put(Operand.getIdString(temp), null);
            } else {
                insertTempVDirectory(temp);
            }

            quadrupleSemantic.getQuadrupleList().add(
                    new Expression(
                            Operator.CARET, op2, op1, temp));
            quadrupleSemantic.getOperandStack().push(temp);
            quadrupleSemantic.getOperandSList().add(temp);
        } else {
            System.out.println("Errro: Printing in rule qWrite with " + op1 + " and " + op2);
        }

        return res;
    }

    //------------------------------------------------------------END ASSIGNMENT, READ AND WRITE
    /**/
    //------------------------------------------------------------BEGIN EXPRESSION

    /**
     * @param rule
     */
    void generateQuadruple(String rule) {
        Operand operand1 = quadrupleSemantic.getOperandStack().peek();
        quadrupleSemantic.getOperandStack().pop();
        Operand operand2 = quadrupleSemantic.getOperandStack().peek();
        quadrupleSemantic.getOperandStack().pop();
        Operator oper = quadrupleSemantic.getOperatorStack().peek();
        quadrupleSemantic.getOperatorStack().pop();
        //cubo semantico
        Type resT = SemanticCube.getCubeType(
                operand1.getType().getTypeValue(), operand2.getType().getTypeValue(), oper.getValue());

        //agregar cuadruplo
        if (!(resT instanceof TypeFalse)) {
            Temporal temp = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), resT);

            if (basicSemantic.isInMethod()) {
                basicSemantic.getEraHash().put(Operand.getIdString(temp), null);
            } else {
                insertTempVDirectory(temp);
            }

            quadrupleSemantic.getQuadrupleList().add(
                    new Expression(
                            oper, operand1, operand2, temp));
            quadrupleSemantic.getOperandStack().push(temp);
            quadrupleSemantic.getOperandSList().add(temp);
        } else {
            System.out.println(rule + " " + resT.getTypeValue());
            System.out.println(operand1.toString() + oper.getOperator() + operand2);
        }
    }

    //------------------------------BEGIN LOGIC OPERATORS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitUAnd(MadBasicParser.UAndContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.AND);
        return super.visitUAnd(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitUOr(MadBasicParser.UOrContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.OR);
        return super.visitUOr(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitT(MadBasicParser.TContext ctx) {
        String res = visitChildren(ctx);
        if (ctx.getChildCount() > 0) {
            generateQuadruple("visitT");
        }
        return res;
    }

    //------------------------------END LOGIC OPERATORS
    /**/
    //------------------------------BEGIN COMPARISON OPERATORS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitZGreater(MadBasicParser.ZGreaterContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.GREATER);
        return super.visitZGreater(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitZLesser(MadBasicParser.ZLesserContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.LESSER);
        return super.visitZLesser(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitZEqualEqual(MadBasicParser.ZEqualEqualContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.EQUALEQUAL);
        return super.visitZEqualEqual(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitZDifferent(MadBasicParser.ZDifferentContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.NOTEQUAL);
        return super.visitZDifferent(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitZzEqual(MadBasicParser.ZzEqualContext ctx) {
        if (quadrupleSemantic.getOperatorStack().peek() == Operator.GREATER) {
            quadrupleSemantic.getOperatorStack().pop();
            quadrupleSemantic.getOperatorStack().push(Operator.GREATEREQUAL);
        } else {
            quadrupleSemantic.getOperatorStack().pop();
            quadrupleSemantic.getOperatorStack().push(Operator.LESSEREQUAL);
        }
        return super.visitZzEqual(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitY(MadBasicParser.YContext ctx) {
        String res = visitChildren(ctx);
        if (ctx.getChildCount() > 0) {
            generateQuadruple("visitY");
        }
        return res;
    }

    //------------------------------END COMPARISON OPERATORS
    /**/
    //------------------------------BEGIN SIMPLE OPERATORS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitWPlus(MadBasicParser.WPlusContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.PLUS);
        return super.visitWPlus(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitWMinus(MadBasicParser.WMinusContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.MINUS);
        return super.visitWMinus(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitV(MadBasicParser.VContext ctx) {
        String res = visitChildren(ctx);
        if (ctx.getChildCount() > 0) {
            generateQuadruple("visitV");
        }
        return res;
    }

    //------------------------------END SIMPLE OPERATORS
    /**/
    //------------------------------BEGIN COMPLEX OPERATORS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitAbDivision(MadBasicParser.AbDivisionContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.DIVISION);
        return super.visitAbDivision(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitAbMultiplication(MadBasicParser.AbMultiplicationContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.MULTIPLICATION);
        return super.visitAbMultiplication(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitAa(MadBasicParser.AaContext ctx) {
        String res = visitChildren(ctx);
        if (ctx.getChildCount() > 0) {
            generateQuadruple("visitAa");
        }
        return res;
    }

    //------------------------------BEGIN COMPLEX OPERATORS
    /**/
    //------------------------------BEGIN UNARY OPERATORS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitAcMinus(MadBasicParser.AcMinusContext ctx) {
        quadrupleSemantic.getOperatorStack().push(Operator.MINUSSOLO);
        return super.visitAcMinus(ctx);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitFactorValue(MadBasicParser.FactorValueContext ctx) {
        String res = visitChildren(ctx);
        Operand var = quadrupleSemantic.getOperandStack().peek();
        if (var instanceof Variable && ((Variable) var).getScope() != basicSemantic.getScopeStack().peek()
                && basicSemantic.isInMethod()) {
//            System.out.println(var);
            Integer dir = virtualMemory.getvDirectory().get(((Variable) var).getID());
            basicSemantic.getEraHash().put(((Variable) var).getID(), dir);
        }
        if (!quadrupleSemantic.getOperatorStack().empty() &&
                quadrupleSemantic.getOperatorStack().peek() == Operator.MINUSSOLO) {
            quadrupleSemantic.getOperatorStack().pop();
            Operand oper = quadrupleSemantic.getOperandStack().peek();
            Type resT = SemanticCube.getCubeType(
                    oper.getType().getTypeValue(), oper.getType().getTypeValue(), Operator.MINUS.getValue());
            if (!(resT instanceof TypeFalse)) {
                Temporal temp = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), resT);

                if (basicSemantic.isInMethod()) {
                    basicSemantic.getEraHash().put(Operand.getIdString(temp), null);
                } else {
                    insertTempVDirectory(temp);
                }

                Constant c = new Constant<Integer>(0, new TypeInt());
                quadrupleSemantic.getQuadrupleList().add(
                        new Expression(
                                Operator.MINUS, oper, c, temp));
                insertConstVDirectory(c);
                quadrupleSemantic.getOperandStack().pop();
                quadrupleSemantic.getOperandStack().push(temp);
                quadrupleSemantic.getOperandSList().add(temp);
            } else {
                System.out.println("visitFactorValue " + resT.getTypeValue());
                String operator = ctx.getChild(0).getText();
                System.out.println(oper.toString() + operator + " " + Operator.MINUSSOLO.getOperator()
                        + oper.toString());
            }
        }
        return res;
    }

    //------------------------------END UNARY OPERATORS
    /**/
    //------------------------------BEGIN VALUE


    void insertConstVDirectory(Constant c) {
        // INT(0), FLOAT(1), STRING(2), BOOL(3), ARRAY(4), OBJECT(5), FALSE(-1);
        switch (c.getType().getTypeValue()) {
            case 0:
                if(virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(c), virtualMemory.getConstIntCount()) == null) {
                    virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstIntCount(), c.getValue());
                    virtualMemory.addConstIntCount();
                }
            case 1:
                if(virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(c), virtualMemory.getConstFloatCount()) == null) {
                    virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstFloatCount(), c.getValue());
                    virtualMemory.addConstFloatCount();
                }
            case 2:
                if(virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(c), virtualMemory.getConstStringCount()) == null) {
                    virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstStringCount(), c.getValue());
                    virtualMemory.addConstStringCount();
                }
            case 3:
                if(virtualMemory.getvDirectory().putIfAbsent(Operand.getIdString(c), virtualMemory.getConstBoolCount()) == null) {
                    virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstBoolCount(), c.getValue());
                    virtualMemory.addConstBoolCount();
                }
        }
    }

    /**
     * @param variable
     */
    void processArray(Variable variable) {
        TypeArray.Array array = ((TypeArray) variable.getType()).getArray();

        for (int i = 0; i < array.getDepth(); i++) {
            TypeArray.Array arraytemp = array.getArray(i);
            Operand index = basicSemantic.getArrayIndexList().removeFirst();
            Constant<Integer> start = new Constant<>(arraytemp.getStart(), new TypeInt());
            Constant<Integer> end = new Constant<>(arraytemp.getEnd(), new TypeInt());
//            virtualMemory.getvDirectory().put(start.getValue().toString(), virtualMemory.getConstIntCount());
//            virtualMemory.addConstIntCount();
            insertConstVDirectory(start);
//            virtualMemory.getvDirectory().put(end.getValue().toString(), virtualMemory.getConstIntCount());
//            virtualMemory.addConstIntCount();
            insertConstVDirectory(end);
            quadrupleSemantic.getQuadrupleList().add(new ArrayVerify(index, start, end));
            Temporal t = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), new TypeInt());

            if (basicSemantic.isInMethod()) {
                basicSemantic.getEraHash().put(Operand.getIdString(t), null);
            } else {
                insertTempVDirectory(t);
            }

            quadrupleSemantic.getQuadrupleList().add(new Expression(
                    Operator.MULTIPLICATION, index, new Constant<>(arraytemp.getM(), new TypeInt()), t));
            quadrupleSemantic.getOperandSList().add(t);
            quadrupleSemantic.getOperandStack().push(t);

            if (i > 0) {
                Operand operand1 = quadrupleSemantic.getOperandStack().pop();
                Operand operand2 = quadrupleSemantic.getOperandStack().pop();
                t = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), new TypeInt());

                if (basicSemantic.isInMethod()) {
                    basicSemantic.getEraHash().put(Operand.getIdString(t), null);
                } else {
                    insertTempVDirectory(t);
                }

                quadrupleSemantic.getQuadrupleList().add(new Expression(Operator.PLUS, operand1, operand2, t));
                quadrupleSemantic.getOperandSList().add(t);
                quadrupleSemantic.getOperandStack().push(t);
            }

        }
        Temporal t = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), new TypeInt());

        if (basicSemantic.isInMethod()) {
            basicSemantic.getEraHash().put(Operand.getIdString(t), null);
        } else {
            insertTempVDirectory(t);
        }

        Constant c = new Constant<>(array.getK(), new TypeInt());
        quadrupleSemantic.getQuadrupleList().add(new Expression(
                Operator.MINUS, c, quadrupleSemantic.getOperandStack().pop(), t));
//        virtualMemory.getvDirectory().put(new Constant<>(array.getK(), new TypeInt()).toString(), virtualMemory.getConstIntCount());
        insertConstVDirectory(c);
        Temporal tt = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), new TypeInt());


        if (basicSemantic.isInMethod()) {
            basicSemantic.getEraHash().put(Operand.getIdString(tt), null);
        } else {
            insertTempVDirectory(tt);
        }

        if(basicSemantic.isArray() && basicSemantic.isArrayandDot()){
            variable = new Variable(variable.getID(), variable.getType(), variable.getScope());
            variable.setAddress(true);
            quadrupleSemantic.getQuadrupleList().add(new Expression(Operator.PLUS, t, variable, tt));
        } else {
            Constant<Integer> memoryIndex =
                    new Constant<>(virtualMemory.getvDirectory().get(variable.getID()), new TypeInt());
            insertConstVDirectory(memoryIndex);
            quadrupleSemantic.getQuadrupleList().add(new Expression(Operator.PLUS, t, memoryIndex, tt));
        }

        Temporal ttt = new Temporal(tt.getID(), ((TypeArray) variable.getType()).getType(), true);

//        if(basicSemantic.isInMethod()){
//            basicSemantic.getEraHash().put(Operand.getIdString(ttt), null);
//        } else {
//            insertTempVDirectory(ttt);
//        }

        quadrupleSemantic.getOperandSList().add(ttt);
        quadrupleSemantic.getOperandStack().push(ttt);
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitSsExp(MadBasicParser.SsExpContext ctx) {
        String result = "";

        if (basicSemantic.isDot()) {
            basicSemantic.setArrayandDot(false);
        } else {
            basicSemantic.setArray(false);
        }

        int cbracket = 3;
        for (int i = 0; i < cbracket && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        Operand operand = quadrupleSemantic.getOperandStack().pop();
        if (operand.getType() instanceof TypeInt) {
            basicSemantic.getArrayIndexList().add(operand);
        } else {
            System.out.println("Error, Operand: " + operand + " not Int!");
        }

        int n = ctx.getChildCount();
        for (int i = cbracket; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        if (basicSemantic.isDot()) {
            basicSemantic.setArrayandDot(true);
        } else {
            basicSemantic.setArray(true);
        }

        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitSDot(MadBasicParser.SDotContext ctx) {
        basicSemantic.setDot(true);
        return super.visitSDot(ctx);
    }

    /**
     * This function adds the founded variables to the getOperandStack(), if they were not
     * found in any scope and error will be displayed at console.
     * This functions searches the variable in a bottom-top search
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitValueIdentifier(MadBasicParser.ValueIdentifierContext ctx) {
        String result = visitChildren(ctx);
        boolean found = false;
        // TODO: 4/20/16 x = ccc[ccc[xi].cc].bb[ccc[bbb.d].cc]; en la linea 113

        if (basicSemantic.isDot()) {
            String text = ctx.getChild(0).getText();
            String[] names = text.split("\\.");
            Scope scope = basicSemantic.getScopeStack().peek();
            Variable arrObj = new Variable(null, null, null);
            if (basicSemantic.isArray()) {
                names[0] = names[0].split("\\[")[0];
                while (scope != null && !found) {
                    if (scope.getVariableHashMap().containsKey(names[0])) {
                        arrObj = scope.getVariableHashMap().get(names[0]);
                        processArray(arrObj);
                    }
                    if (!found) {
                        scope = scope.getParent();
                    }
                }
            }
            scope = basicSemantic.getScopeStack().peek();
            while (scope != null && !found) {
                if (scope.getVariableHashMap().containsKey(names[0])) {
                    names[1] = names[1].split("\\[")[0];
                    if (basicSemantic.isArray()) {
                        if (((TypeObject) ((TypeArray) arrObj.getType()).getType()).
                                getClasse().getScope().getVariableHashMap().containsKey(names[1])) {
                            Variable var =
                                    ((TypeObject) ((TypeArray) arrObj.getType()).getType()).
                                            getClasse().getScope().getVariableHashMap().get(names[1]);
                            if (!basicSemantic.isArrayandDot()) {
                                var = new Variable(
                                        Operand.getIdString(quadrupleSemantic.getOperandStack().pop())
                                                + "." + var.getID(), var.getType(), var.getScope());
                                quadrupleSemantic.getOperandStack().push(var);
                                quadrupleSemantic.getOperandSList().add(var);
                            } else {
                                System.out.println(var);
                                processArray(var);
                                basicSemantic.setArrayandDot(false);
                            }
                            found = true;
                        }
                        basicSemantic.setArray(false);
                    } else if (((TypeObject) scope.getVariableHashMap().get(names[0]).getType())
                            .getClasse().getScope().getVariableHashMap().containsKey(names[1])) {
                        Variable var =
                                ((TypeObject) scope.getVariableHashMap().get(names[0]).getType())
                                        .getClasse().getScope().getVariableHashMap().get(names[1]);
                        if (!basicSemantic.isArrayandDot()) {
                            var = new Variable(names[0] + "." + var.getID(), var.getType(), var.getScope());
                            quadrupleSemantic.getOperandStack().push(var);
                            quadrupleSemantic.getOperandSList().add(var);
                        } else {
                            processArray(var);
                            basicSemantic.setArrayandDot(false);
                        }
                        found = true;
                    }
                }
                if (!found) {
                    scope = scope.getParent();
                }
            }
            if (!found) {
                System.out.println("Error, Identifier: " + text + " not found1!");
            }
            basicSemantic.setDot(false);

        } else {
            String text = ctx.getChild(0).getText();
            text = text.split("\\[")[0];
            Scope scope = basicSemantic.getScopeStack().peek();
            while (scope != null && !found) {
                if (scope.getVariableHashMap().containsKey(text)) {
                    if (!basicSemantic.isArray()) {
                        quadrupleSemantic.getOperandStack().push(scope.getVariableHashMap().get(text));
                        quadrupleSemantic.getOperandSList().add(scope.getVariableHashMap().get(text));
                    } else {
                        processArray(scope.getVariableHashMap().get(text));
                        basicSemantic.setArray(false);
                    }
                    found = true;
                }
                if (!found) {
                    scope = scope.getParent();
                }
            }
            if (!found) {
                System.out.println("Error, Identifier: " + text + " not found2!");
            }
        }
        return result;
    }

    /**
     * Function that adds a constant integer value to the getOperandStack()
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitValueInt(MadBasicParser.ValueIntContext ctx) {
        String text = ctx.getChild(0).getText();
        quadrupleSemantic.getOperandStack().push(new Constant<Integer>(new Integer(text), new TypeInt()));
        quadrupleSemantic.getOperandSList().add(new Constant<Integer>(new Integer(text), new TypeInt()));
        if (virtualMemory.getvDirectory().putIfAbsent(text, virtualMemory.getConstIntCount()) == null) {
            virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstIntCount(), new Integer(text));
            virtualMemory.addConstIntCount();
        }
        return super.visitValueInt(ctx);
    }

    /**
     * Function that adds a constant float value to the getOperandStack()
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitValueFloat(MadBasicParser.ValueFloatContext ctx) {
        String text = ctx.getChild(0).getText();
        quadrupleSemantic.getOperandStack().push(new Constant<Float>(new Float(text), new TypeFloat()));
        quadrupleSemantic.getOperandSList().add(new Constant<Float>(new Float(text), new TypeFloat()));
        if (virtualMemory.getvDirectory().putIfAbsent(text, virtualMemory.getConstFloatCount()) == null) {
            virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstFloatCount(), new Float(text));
            virtualMemory.addConstFloatCount();
        }
        return super.visitValueFloat(ctx);
    }

    /**
     * Function that adds a string to the getOperandStack()
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitValueString(MadBasicParser.ValueStringContext ctx) {
        String text = ctx.getChild(0).getText();
        quadrupleSemantic.getOperandStack().push(new Constant<String>(text, new TypeString()));
        quadrupleSemantic.getOperandSList().add(new Constant<String>(text, new TypeString()));
        if (virtualMemory.getvDirectory().putIfAbsent(text, virtualMemory.getConstStringCount()) == null) {
            virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstStringCount(), text);
            virtualMemory.addConstStringCount();
        }
        return super.visitValueString(ctx);
    }

    /**
     * Function that adds a boolean value to the getOperandStack()
     *
     * @param ctx
     * @return
     */
    @Override
    public String visitValueBool(MadBasicParser.ValueBoolContext ctx) {
        String text = ctx.getChild(0).getText();
        quadrupleSemantic.getOperandStack().push(new Constant<Boolean>(new Boolean(text), new TypeBool()));
        quadrupleSemantic.getOperandSList().add(new Constant<Boolean>(new Boolean(text), new TypeBool()));
        if (virtualMemory.getvDirectory().putIfAbsent(text, virtualMemory.getConstBoolCount()) == null) {
            virtualMemory.getvMemory().putIfAbsent(virtualMemory.getConstBoolCount(), new Boolean(text));
            virtualMemory.addConstBoolCount();
        }
        return super.visitValueBool(ctx);
    }

    //------------------------------END VALUE
    /**/
    //------------------------------BEGIN CALL

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitArgs(MadBasicParser.ArgsContext ctx) {
        String result = this.defaultResult();

        int n = ctx.getChildCount() - 1;
        for (int i = 0; i < 2 && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }



        if (basicSemantic.isFoundAReference()) { // Check if its a variable sent by reference
            try {
                Variable var = (Variable) quadrupleSemantic.getOperandStack().pop();
                var.setByReference(true);
                basicSemantic.setFoundAReference(false);
                ParseTree c = ctx.getChild(n);
                String childResult = c.accept(this);
                result = this.aggregateResult(result, childResult);
                quadrupleSemantic.getArgsStack().push(var);
            } catch (ClassCastException e) {
                System.out.println("You can't send constants by reference");
            }
        } else {
            ParseTree c = ctx.getChild(n);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
            quadrupleSemantic.getArgsStack().push(quadrupleSemantic.getOperandStack().pop());
        }


        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitXArgs(MadBasicParser.XArgsContext ctx) {
        String result = this.defaultResult();

        int n = ctx.getChildCount() - 1;
        for (int i = 0; i < 3 && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        if (basicSemantic.isFoundAReference()) { // Check if its a variable sent by reference
            try {
                Variable var = (Variable) quadrupleSemantic.getOperandStack().pop();
                var.setByReference(true);
                basicSemantic.setFoundAReference(false);
                ParseTree c = ctx.getChild(n);
                String childResult = c.accept(this);
                result = this.aggregateResult(result, childResult);
                quadrupleSemantic.getArgsStack().push(var);

            } catch (ClassCastException e) {
                System.out.println("You can't send constants by reference");
            }
        } else {
            ParseTree c = ctx.getChild(n);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
            quadrupleSemantic.getArgsStack().push(quadrupleSemantic.getOperandStack().pop());
        }

         return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitCall(MadBasicParser.CallContext ctx) {
        String result = "";
        quadrupleSemantic.setArgsStack(new Stack<>());
        // TODO: 4/10/16 modificar si hashtable y para funciones dentro de clases

        ParseTree c = ctx.getChild(0);
        String childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);

        Procedure method = null;
        String methodName = ctx.getChild(0).getText();
        String objname = "";

        if (basicSemantic.isDot()) {
            String[] names = methodName.split("\\.");
            objname = names[0].split("\\[")[0];
            Scope scope = basicSemantic.getScopeStack().peek();
            if (basicSemantic.isArray()) {
                basicSemantic.setArray(false);
                for (Scope s : basicSemantic.getScopeStack()) {
                    if (s.getVariableHashMap().containsKey(objname)) {
                        processArray(scope.getVariableHashMap().get(objname));
                        names[0] = objname;
                        Operand obj = quadrupleSemantic.getOperandStack().pop();
                        if (((TypeObject) obj.getType())
                                .getClasse().getScope().getProcedureHashMap().containsKey(names[1])) {
                            method = ((TypeObject) obj.getType())
                                    .getClasse().getScope().getProcedureHashMap().get(names[1]);
                            objname = Operand.getIdString(obj).concat("-");
                            break;
                        }

                    }
                }
            } else {
                while (scope != null) {
                    if (scope.getVariableHashMap().containsKey(names[0])) {
                        if (((TypeObject) scope.getVariableHashMap().get(names[0])
                                .getType()).getClasse().getScope().getProcedureHashMap().containsKey(names[1])) {
                            method = ((TypeObject) scope.getVariableHashMap().get(names[0])
                                    .getType()).getClasse().getScope().getProcedureHashMap().get(names[1]);
                            objname = objname.concat("-");
                            break;
                        }
                    }
                    scope = scope.getParent();
                }
            }
            basicSemantic.setDot(false);
        } else {
            for (Scope scope : basicSemantic.getScopeStack()) {
                if (scope.getProcedureHashMap().containsKey(methodName)) {
                    method = scope.getProcedureHashMap().get(methodName);
                    break;
                }
            }
        }

        if (method != null) {
            Procedure methodQuad = method.clone();
            methodQuad.setID(objname + method.getID());
            QuadEra era = new QuadEra(methodQuad);
            quadrupleSemantic.getQuadrupleList().add(era);

            int n = ctx.getChildCount();
            for (int i = 1; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
                c = ctx.getChild(i);
                childResult = c.accept(this);
                result = this.aggregateResult(result, childResult);
            }

            if (quadrupleSemantic.getArgsStack().size() == method.getParams().size()) {
                for (int i = 0; i < method.getParams().size(); i++) {
                    Variable var = method.getParams().get(i);
                    Operand oper = quadrupleSemantic.getArgsStack().pop();
                    if (oper.getType().equals(var.getType()) &&
                            (!(oper instanceof Variable) || ((Variable) oper).isByReference() == var.isByReference())) {
                        quadrupleSemantic.getQuadrupleList().add(new Parameter(oper, i));
                    } else {
                        // TODO: 4/11/16 error, explain the actual error
                        System.out.println("Error on call " + ctx.getChild(0).getText());
                    }
                }

                int jumpback = quadrupleSemantic.getQuadrupleList().size() + 1;
                quadrupleSemantic.getQuadrupleList().add(new Gosub(jumpback, methodQuad));
                if (method instanceof Function) {
                    Variable var = method.getScope().getParent().getVariableHashMap().get(method.getID());
                    Temporal temp = new Temporal(quadrupleSemantic.getTemporalCountAndStep(), var.getType());

                    if (basicSemantic.isInMethod()) {
                        basicSemantic.getEraHash().put(Operand.getIdString(temp), null);
                    } else {
                        insertTempVDirectory(temp);
                    }

                    quadrupleSemantic.getQuadrupleList().add(new Assignment(var, temp));
                    quadrupleSemantic.getOperandSList().add(temp);
                    quadrupleSemantic.getOperandStack().push(temp);
                }
            } else {
                // TODO: 4/10/16 error
                System.out.println("Error on call " + ctx.getChild(0).getText() + " paramsize");
            }
        } else

        {
            // TODO: 4/10/16 error
            System.out.println("Error on call \"" + ctx.getChild(0).getText() + "\" non existent");
        }

        return result;
    }

    //------------------------------END CALL
    /**/
    //------------------------------------------------------------END EXPRESSION
    /**/
    //------------------------------------------------------------BEGIN CONDITION

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitCondition(MadBasicParser.ConditionContext ctx) {
        String result = this.defaultResult();
        int n = ctx.getChildCount();

        for (int i = 0; i < 4 && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        Operand condition = quadrupleSemantic.getOperandStack().peek();
        quadrupleSemantic.getOperandStack().pop();
        if (condition.getType() instanceof TypeBool) {
            GotoFalse gotoFalse = new GotoFalse(condition);
            quadrupleSemantic.getJumpStack().add(quadrupleSemantic.getQuadrupleList().size());
            quadrupleSemantic.getQuadrupleList().add(gotoFalse);
        } else {
            System.out.println("Error, Identifier: " + ctx.getChild(2).getText() + " not bool!");
        }

        for (int i = 4; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        Integer fin = quadrupleSemantic.getJumpStack().pop();
        ((Goto) quadrupleSemantic.getQuadrupleList().get(fin)).setJump(quadrupleSemantic.getQuadrupleList().size());

        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitPElse(MadBasicParser.PElseContext ctx) {
        Goto go = new Goto();
        Integer falso = quadrupleSemantic.getJumpStack().pop();
        quadrupleSemantic.getJumpStack().add(quadrupleSemantic.getQuadrupleList().size());
        quadrupleSemantic.getQuadrupleList().add(go);
        ((Goto) quadrupleSemantic.getQuadrupleList().get(falso)).setJump(quadrupleSemantic.getQuadrupleList().size());
        return super.visitPElse(ctx);
    }

    //------------------------------------------------------------END CONDITION
    /**/
    //------------------------------------------------------------BEGIN LOOP

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitLoop(MadBasicParser.LoopContext ctx) {
        String result = this.defaultResult();
        int n = ctx.getChildCount();

        quadrupleSemantic.getJumpStack().add(quadrupleSemantic.getQuadrupleList().size());

        for (int i = 0; i < 4 && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        Operand condition = quadrupleSemantic.getOperandStack().pop();
        if (condition.getType() instanceof TypeBool) {
            GotoFalse gotoFalse = new GotoFalse(condition);
            quadrupleSemantic.getJumpStack().add(quadrupleSemantic.getQuadrupleList().size());
            quadrupleSemantic.getQuadrupleList().add(gotoFalse);
        } else {
            System.out.println("Error, Identifier: " + ctx.getChild(2).getText() + " not bool!");
        }

        for (int i = 4; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        Integer fin = quadrupleSemantic.getJumpStack().pop();
        Integer retorno = quadrupleSemantic.getJumpStack().pop();
        quadrupleSemantic.getQuadrupleList().add(new Goto(retorno));
        ((Goto) quadrupleSemantic.getQuadrupleList().get(fin)).setJump(quadrupleSemantic.getQuadrupleList().size());

        return result;
    }

    //------------------------------------------------------------END LOOP
     /**/
    //------------------------------------------------------------BEGIN METHODS

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitMethod(MadBasicParser.MethodContext ctx) {
        basicSemantic.setParamList(new LinkedList<>());
        basicSemantic.setInMethod(true);
        String res = visitChildren(ctx);
        basicSemantic.setInMethod(false);
        return res;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitParams(MadBasicParser.ParamsContext ctx) {
        String result = this.defaultResult();
        basicSemantic.setParams(true);

        int n = ctx.getChildCount();
        for (int i = 0; i < 3 && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        // TODO: 4/11/16 reference

        Type type = basicSemantic.getTypeStack().pop();
        while (!basicSemantic.getTypeStack().empty()) {
            if (type instanceof TypeList) {
                ((TypeList) type).setType(basicSemantic.getTypeStack().pop());
            } else if (basicSemantic.getTypeStack().peek() instanceof TypeArray) {
                ((TypeArray) basicSemantic.getTypeStack().peek()).setType(type);
                type = basicSemantic.getTypeStack().pop();
            }
        }

//        basicSemantic.setParamList(new LinkedList<>());
        Variable variable = new Variable(ctx.getChild(2).getText(), type, basicSemantic.getScopeStack().peek(), basicSemantic.isFoundAReference());
        basicSemantic.setFoundAReference(false);
        basicSemantic.getParamList().add(variable);
//        System.out.println(variable);
        virtualMemory.getvDirectory().putIfAbsent(variable.getID(), -1);

        for (int i = 3; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        basicSemantic.setParams(false);

        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitN(MadBasicParser.NContext ctx) {
        String result = this.defaultResult();
        int n = ctx.getChildCount();
        if (n > 0) {
            for (int i = 0; i < 4 && this.shouldVisitNextChild(ctx, null); ++i) {
                ParseTree c = ctx.getChild(i);
                String childResult = c.accept(this);
                result = this.aggregateResult(result, childResult);
            }

            // TODO: 4/11/16 reference pending
            Type type = basicSemantic.getTypeStack().pop();
            while (!basicSemantic.getTypeStack().empty()) {
                if (type instanceof TypeList) {
                    ((TypeList) type).setType(basicSemantic.getTypeStack().pop());
                } else if (basicSemantic.getTypeStack().peek() instanceof TypeArray) {
                    ((TypeArray) basicSemantic.getTypeStack().peek()).setType(type);
                    type = basicSemantic.getTypeStack().pop();
                }
            }


            Variable variable = new Variable(ctx.getChild(3).getText(), type, basicSemantic.getScopeStack().peek(), basicSemantic.isFoundAReference());
            basicSemantic.setFoundAReference(false);
            basicSemantic.getParamList().add(variable);
//            System.out.println(variable);
            virtualMemory.getvDirectory().putIfAbsent(variable.getID(), -1);

            for (int i = 4; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
                ParseTree c = ctx.getChild(i);
                String childResult = c.accept(this);
                result = this.aggregateResult(result, childResult);
            }
        }
        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitInit(MadBasicParser.InitContext ctx) {
        basicSemantic.setParamList(new LinkedList<>());
        String result = "";

        String id = "init";

        for (Scope scope : basicSemantic.getScopeStack()) {
            if (scope.getProcedureHashMap().containsKey(id) || scope.getVariableHashMap().containsKey(id)) {
                System.out.println("Error on func " + id);
            }
        }

        Procedure proc = new Procedure(id, basicSemantic.getScopeStack().peek());
        basicSemantic.getScopes().add(proc.getScope());
        basicSemantic.getScopeStack().push(proc.getScope());

        int cParentesisIndex = 4;
        for (int i = 0; i < cParentesisIndex && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        proc.setParams(basicSemantic.getParamList());
        //proc.getScope().getVariables().addAll(basicSemantic.getParamList());

        for (Variable var : basicSemantic.getParamList()) {
            proc.getScope().getVariableHashMap().put(var.getID(), var);
        }

        proc.setQuadrupleStart(quadrupleSemantic.getQuadrupleList().size());
        basicSemantic.getProcedures().add(proc);
        basicSemantic.getScopeStack().peek().getParent().getProcedureHashMap().put(id, proc);
        Variable var = new Variable(proc.getID(), new TypeFalse(), proc.getScope().getParent());
        basicSemantic.getScopeStack().peek().getParent().getVariableHashMap().put(id, var);
        insertVDirectory(var);

        int n = ctx.getChildCount();
        for (int i = cParentesisIndex; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        quadrupleSemantic.getQuadrupleList().add(new Retorno());
        proc.setEra(basicSemantic.getEraHash());
        basicSemantic.setEraHash(new HashMap<>());
        basicSemantic.getScopeStack().pop();

        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitFunction(MadBasicParser.FunctionContext ctx) {
        String result = "";
        ParseTree c = ctx.getChild(0);
        String childResult = c.accept(this);
        result = this.aggregateResult(result, childResult);

        Type type = basicSemantic.getTypeStack().pop();
        while (!basicSemantic.getTypeStack().empty()) {
            ((TypeList) type).setType(basicSemantic.getTypeStack().pop());
        }

        String id = ctx.getChild(1).getText();

        for (Scope scope : basicSemantic.getScopeStack()) {
            if (scope.getProcedureHashMap().containsKey(id) || scope.getVariableHashMap().containsKey(id)) {
                System.out.println("Error on func " + id);
            }
        }

        Function func = new Function(id, type, basicSemantic.getScopeStack().peek());
        basicSemantic.setActualType(type); // Set the actual time
        basicSemantic.getScopes().add(func.getScope());
        basicSemantic.getScopeStack().push(func.getScope());

        int cParentesisIndex = 5;
        for (int i = 1; i < cParentesisIndex && this.shouldVisitNextChild(ctx, null); ++i) {
            c = ctx.getChild(i);
            childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        func.setParams(basicSemantic.getParamList());
        //func.getScope().getVariables().addAll(basicSemantic.getParamList());

        for (Variable var : basicSemantic.getParamList()) {
            func.getScope().getVariableHashMap().put(var.getID(), var);
        }

        func.setQuadrupleStart(quadrupleSemantic.getQuadrupleList().size());
        basicSemantic.getProcedures().add(func);
        basicSemantic.getScopeStack().peek().getParent().getProcedureHashMap().put(id, func);
        Variable var = new Variable(func.getID(), func.getType(), func.getScope().getParent());
        basicSemantic.getScopeStack().peek().getParent().getVariableHashMap().put(id, var);
        insertVDirectory(var);

        int n = ctx.getChildCount();
        for (int i = cParentesisIndex; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            c = ctx.getChild(i);
            childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        quadrupleSemantic.getQuadrupleList().add(new Retorno());
        basicSemantic.resetActualType(); // Reset the actual type
        func.setEra(basicSemantic.getEraHash());
        basicSemantic.setEraHash(new HashMap<>());
        basicSemantic.getScopeStack().pop();

        return result;
    }

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitProcedure(MadBasicParser.ProcedureContext ctx) {
        String result = "";

        String id = ctx.getChild(1).getText();

        for (Scope scope : basicSemantic.getScopeStack()) {
            if (scope.getProcedureHashMap().containsKey(id) || scope.getVariableHashMap().containsKey(id)) {
                System.out.println("Error on func " + id);
            }
        }

        Procedure proc = new Procedure(id, basicSemantic.getScopeStack().peek());
        basicSemantic.getScopes().add(proc.getScope());
        basicSemantic.getScopeStack().push(proc.getScope());

        int cParentesisIndex = 5;
        for (int i = 0; i < cParentesisIndex && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        proc.setParams(basicSemantic.getParamList());
        //proc.getScope().getVariables().addAll(basicSemantic.getParamList());

        for (Variable var : basicSemantic.getParamList()) {
            proc.getScope().getVariableHashMap().put(var.getID(), var);
        }

        proc.setQuadrupleStart(quadrupleSemantic.getQuadrupleList().size());
        basicSemantic.getProcedures().add(proc);
        basicSemantic.getScopeStack().peek().getParent().getProcedureHashMap().put(id, proc);
        Variable var = new Variable(proc.getID(), new TypeFalse(), proc.getScope().getParent());
        basicSemantic.getScopeStack().peek().getParent().getVariableHashMap().put(id, var);
        insertVDirectory(var);

        int n = ctx.getChildCount();
        for (int i = cParentesisIndex; i < n && this.shouldVisitNextChild(ctx, null); ++i) {
            ParseTree c = ctx.getChild(i);
            String childResult = c.accept(this);
            result = this.aggregateResult(result, childResult);
        }

        quadrupleSemantic.getQuadrupleList().add(new Retorno());
        proc.setEra(basicSemantic.getEraHash());
        basicSemantic.setEraHash(new HashMap<>());
        basicSemantic.getScopeStack().pop();

        return result;
    }

    //------------------------------------------------------------END METHODS
    /**/
    //------------------------------------------------------------START RETURN

    /**
     * @param ctx
     * @return
     */
    @Override
    public String visitRetorno(MadBasicParser.RetornoContext ctx) {
        String result = visitChildren(ctx);

        if (basicSemantic.getActualType().equals(quadrupleSemantic.getOperandStack().peek().getType())) {

            Scope actualScope = basicSemantic.getScopeStack().peek();
//            System.out.println("TEST SCOPE NAME: " + actualScope.getName());

//            System.out.println("Value: " + quadrupleSemantic.getOperandStack().peek() + " -> " +  actualScope.getParent().getVariableHashMap().get(actualScope.getName()));
            quadrupleSemantic.getQuadrupleList().add(
                    new Assignment(quadrupleSemantic.getOperandStack().pop(),
                            actualScope.getParent().getVariableHashMap().get(actualScope.getName()))
            );

        } else {
            //TODO FORMAT THIS ERROR LOG
            System.out.println("ERROR IN RETURN: WRONG TYPE");
        }

        return result;
    }

    //------------------------------------------------------------END RETURN
    /**/
    //------------------------------------------------------------BEGIN MADBASIC

    @Override
    public String visitMadbasic(MadBasicParser.MadbasicContext ctx) {
        quadrupleSemantic.getQuadrupleList().add(new Goto());

        String res = visitChildren(ctx);

        quadrupleSemantic.getQuadrupleList().add(new End());

        virtualMemory.setQuadruples(quadrupleSemantic.getQuadrupleList());

        return res;
    }

    //------------------------------------------------------------END MADBASIC
    /**/
    //------------------------------------------------------------------------------------------END QUADRUPLES

}
